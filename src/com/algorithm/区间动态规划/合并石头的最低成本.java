package com.algorithm.区间动态规划;

/*
* 有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。

每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。

找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。

 

示例 1：

输入：stones = [3,2,4,1], K = 2
输出：20
解释：
从 [3, 2, 4, 1] 开始。
合并 [3, 2]，成本为 5，剩下 [5, 4, 1]。
合并 [4, 1]，成本为 5，剩下 [5, 5]。
合并 [5, 5]，成本为 10，剩下 [10]。
总成本 20，这是可能的最小值。
示例 2：

输入：stones = [3,2,4,1], K = 3
输出：-1
解释：任何合并操作后，都会剩下 2 堆，我们无法再进行合并。所以这项任务是不可能完成的。.
示例 3：

输入：stones = [3,5,1,2,6], K = 3
输出：25
解释：
从 [3, 5, 1, 2, 6] 开始。
合并 [5, 1, 2]，成本为 8，剩下 [3, 8, 6]。
合并 [3, 8, 6]，成本为 17，剩下 [17]。
总成本 25，这是可能的最小值。
 

提示：

1 <= stones.length <= 30
2 <= K <= 30
1 <= stones[i] <= 100
*
* */

/*
* 细节
第一点：一定会有不能合并成1堆的情况，怎么排除掉这种情况呢？
如果能合并成1堆，就一定得先合并成k堆，这在前面已经讨论过了。这k堆里面的其中1堆，也是由k堆合并而来的，这样一直套娃，就能还原到原始的堆数n。我们由此可以定义一个方程：k + (k - 1) * a == n，a是一个大于等于0的整数。
推算一下，有：k - 1 + (k - 1) * a == n - 1 \Rightarrow⇒ (k - 1) * (a + 1) == n - 1。
所以对于有解的情况，一定有(n - 1) % (k - 1) == 0。

第二点：为什么划分的方式是左部分合并成1堆，右部分合并成k-1堆？左部分k-1，右部分1；左部分2，右部分k-2...这些方式可行吗？
可行的划分方式只能是1和k-1，左右当然不重要。

首先说明1和k-1能完整覆盖到所有情况：
如果对于dp[i][j][m]，它的最优划分是dp[i][p][2] + dp[p + 1][j][m - 2]，
那么dp[i][p][2] = dp[i][p1][1] + dp[p1 + 1][p][1]，p1为最优划分点。
代入一下，就有dp[i][j][m] = dp[i][p1][1] + dp[p1 + 1][p][1] + dp[p + 1][j][m - 2]。
后面那俩合并一下就是k-1堆的情况，所以说1和k-1的划分方式是正确的。

再说明为什么2和k-2的划分是错误的：
这一点要从递归的角度，自顶向下地来看就好理解。我们要求解的是solve(1, n, 1)，由于堆数为1，所以会递归调用solve(1, n, k)。堆数为k，需要进行划分来求解，分别调用solve(1, p, 2)和solve(p + 1, n, k - 2)，p从1到n-1循环。当p == 1和p == 2时我们都知道结果，但当3 <= p < n呢？solve(1, p, 2)不是一个初始状态，也不是可以划分的状态，也不知道是不是合法的状态，这就变成了一个无法求解的状态，所以划分是错误的。
再回到dp的角度，其实也就是dp[i][p][2]是无法求解的，合并成2堆不是一个子问题，而我们定义的划分方式又导致它无法继续分解为子问题，那它就肯定无法求解了。

第三点：枚举分界点时，step应该是k - 1而不是1。
step为1当然也是正确的，但是却进行了很多无用的计算，导致运行时间增加。为什么step可以是k-1呢？因为我们设计的划分是将左部分区间[i, p]合并为1堆，那就一定有(p - i) % (k - 1) == 0，结合最初p = i，就可以知道step应该是k-1，这样会涵盖所有有效的分界点p。对于其他的分界点p，左部分不能合并为1堆，那这样的划分并没有意义，对于计算答案也就没有帮助了。
* */

public class 合并石头的最低成本 {
    // 不用Integer.MAX_VALUE,因为Integer.MAX_VALUE + 正数 会溢出变为负数
    private int MAX_VALUE = 99999999;
    public int mergeStones(int[] stones, int k) {
        int n = stones.length;
        if ((n - 1) % (k - 1) != 0) {
            return -1;
        }
        int[][][] dp = new int[n + 1][n + 1][k + 1];
        int[] sum = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            sum[i] = sum[i - 1] + stones[i - 1];
        }
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j++) {
                for (int m = 2; m <= k; m++) {
                    dp[i][j][m] = MAX_VALUE;
                }
            }
            dp[i][i][1] = 0;
        }
        for (int len = 2; len <= n; len++) {// 枚举区间长度
            for (int i = 1; i + len - 1 <= n; i++) {// 枚举区间起点
                int j = i + len - 1;
                for (int m = 2; m <= k; m++) {// 枚举堆数
                    // dp[i][j][m] = MAX_VALUE;
                    for (int p = i; p < j; p += k - 1) {// 枚举分界点
                        dp[i][j][m] = Math.min(dp[i][j][m], dp[i][p][1] + dp[p + 1][j][m - 1]);
                    }
                }
                dp[i][j][1] = dp[i][j][k] + sum[j] - sum[i - 1];
            }
        }
        return dp[1][n][1];
    }
}
