package com.algorithm.图;

/*
* 在本问题中, 树指的是一个连通且无环的无向图。

输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。

结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u < v，表示连接顶点u 和v的无向图的边。

返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u < v。

示例 1：

输入: [[1,2], [1,3], [2,3]]
输出: [2,3]
解释: 给定的无向图为:
  1
 / \
2 - 3
示例 2：

输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]
输出: [1,4]
解释: 给定的无向图为:
5 - 1 - 2
    |   |
    4 - 3
注意:

输入的二维数组大小在 3 到 1000。
二维数组中的整数在1到N之间，其中N是输入数组的大小。

* */

/*
*
方法一：并查集
在一棵树中，边的数量比节点的数量少 11。如果一棵树有 NN 个节点，则这棵树有 N-1N−1 条边。这道题中的图在树的基础上多了一条附加的边，因此边的数量也是 NN。

树是一个连通且无环的无向图，在树中多了一条附加的边之后就会出现环，因此附加的边即为导致环出现的边。

可以通过并查集寻找附加的边。初始时，每个节点都属于不同的连通分量。遍历每一条边，判断这条边连接的两个顶点是否属于相同的连通分量。

如果两个顶点属于不同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间不连通，因此当前的边不会导致环出现，合并这两个顶点的连通分量。

如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为附加的边，将当前的边作为答案返回。

*
* 时间复杂度：O(N \log N)O(NlogN)，其中 NN 是图中的节点个数。需要遍历图中的 NN 条边，对于每条边，需要对两个节点查找祖先，如果两个节点的祖先不同则需要进行合并，需要进行 22 次查找和最多 11 次合并。一共需要进行 2N2N 次查找和最多 NN 次合并，
* 因此总时间复杂度是 O(2N \log N)=O(N \log N)O(2NlogN)=O(NlogN)
*
*
* 其他解法
* 一、 DFS
求邻接表，然后从后往前遍历各边，针对每条边，先把该边对应邻接表中的两个端点删除，然后遍历该边的一端。如果成功遍历到另一端点说明有环，返回该边即可。

二、拓扑排序
相比于DFS不仅需要邻接表，还需要各点入度表，针对有向图，入度为0的端点作为遍历的起点。本题为无向图，入度最少为1，将入度为1的点加入队列，然后每次删除队列中弹出的入度为1的点所连的点，表现为对应端点的入度值减一，如果对应端点入度为1，将其加入队列，重复步骤。针对有向图，如果有入度不为0的点存在，表示删除结束后仍存在入度不为0的点，即存在环；针对本题（无向图），从后往前遍历每条边，如果某条边两端端点入度均大于1时，返回该边。
* * */

class 冗余连接 {

    private int[] parent;

    public int[] findRedundantConnection(int[][] edges) {
        int n = edges.length;
        parent = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            parent[i] = i;
        }
        for (int[] edge: edges) {
            int root1 = find(edge[0]);
            int root2 = find(edge[1]);
            if (root1 == root2) {
                return edge;
            } else {
                union(root1, root2);
            }
        }
        return new int[0];
    }
    public int find(int x) {
        while (parent[x] != x) {
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }
    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            parent[rootX] = parent[rootY];
        }
    }
}